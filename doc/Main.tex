\documentclass{scrbook}
\KOMAoptions{parskip=half*}
\usepackage{mathtools}
\numberwithin{equation}{chapter}
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{exs}{Exercise}[chapter]
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=gray,
  urlcolor=purple
}
\usepackage[inkscapeformat=png]{svg}
\usepackage[chapter,newfloat=true]{minted}
\usemintedstyle[haskell]{lovelace}
\newminted[code]{haskell}{bgcolor=bgh}
\newminted[spec]{haskell}{bgcolor=bgh}
\usemintedstyle[cpp]{autumn}
\newminted[cpp]{cpp}{bgcolor=bgc}

\begin{document}
\definecolor{bgh}{rgb}{0.96,0.96,0.98}
\definecolor{bgc}{rgb}{0.95,0.98,0.95}

\frontmatter
\title{Mastering Algorithms and Data Structures}
\author{Oliver Krischer}
\subtitle{A Hands-on Introduction to Computation with $C^{++}$ and $Haskell$}
\maketitle
\tableofcontents
\listoffigures
\chapter{Preface}
Really, another book on data structures and algorithms?

While there are a myriad of resources on this topic, most of them concentrate solely at
algorithm design, providing no help for implementing the algorithms in an actual programming lnguage.
Others show a poor program design when using a concrete language, especially when algorithms become
more complex.
All together, existing resources on the topic ignore the aspect of concurrent and parallel
computing, which seems critical to me.

Those resources are nontheless valuable in there own right, but this book tries to be different:
a practical guide to writing well-designed programs and algorithms in two completely different
programming languages ($Haskell \ \text{and} \ C^{++}$), providing complete solutions to all
presented problems and making use of concurrent programming whenever promising profit of doing so.

This document is not a textbook, and does not concentrate on academical aspects of algorithm
or program design.
Instead, we are going to explore some (hopefully) interesting applications of the
presented concepts, which might allow you to grasp these concepts easily and bring
them to bear in your own programming experience.

Therefore, this document contains a lot of sourcecode. Code in \emph{Haskell} is
printed on a light blue background, while $C^{++}$ code is printed on a
light green background.
As all text files of this document are encoded as \emph{literate Haskell} files (.lhs),
you can load them into \texttt{ghci} and excute every contained Haskell function.
In order to run the $C^{++}$ code, I have provided a \emph{CMake} file in the root folder
of this project.
With that, you can build the whole $C^{++}$ project with a single command and then run the provided
applications.

For some of the solutions simple benchmarks are provided.
Please keep in mind that those benchmarks have no absolute meaning, as no effort
was taken to standarize the benchmarks results of both languages.
Thus, you can never say that \emph{Haskell} is faster than $C^{++}$ or vice versa.

The sourcecode repository of this project can be found at
\href{https://github.com/okrischer/mastering}{github}, and you are welcome to clone
the repository and play with the code to your liking.

However, please notice that this is work in progress: only a fraction of the content
I plan to create, is available at this time. But all existing code is well tested and
should work properly. Alas, happy coding!

\mainmatter
\part{Program Design}
The first part of this book is about \emph{program design}.
Insead of exploring numerous programming paradigms, we will concentrate on
\emph{declarative programming} and how to embrace \emph{parallelism} in your programs.

Declarative programming is about program design. According to
\href{https://en.wikipedia.org/wiki/Declarative_programming}{wikipedia},
it is a non-imperative style of programming in which programs describe their desired
results without explicitly listing commands or steps that must be performed.

Incorporating a declarative style will allow you to express your thoughts clearly by using
expressive and comprehensive language constructs.
To that goal, we will explore \emph{Recursion} (ยง~\ref{ch:recursion}) and
\emph{Functional Programming} (ยง~\ref{ch:functional}) in their respective chapters.

To be honest, if you are not using recursion in your programs today, or have virtually no
experience with functional programming, you will have a rough time in grasping those concepts.
But that's okay; just skim over this first part and proceed with Part II: \emph{Data Structures}.
There we will lay the foundations of a good programming style based on simple code snippets.
But make sure to come back to the first part and give it another try afterwards.
It will be rewarding, I promise.

Finally, we will explore the fundamentals of \emph{Concurrent Programming}
(ยง~\ref{ch:concurrent}) and \emph{Parallel Programming} (ยง~\ref{ch:parallel})
in their respective chapters.

\input{Recursion.lhs}
\input{Functional.lhs}
\input{Concurrency.tex}
\input{Parallel.tex}

\part{Data Structures}

Any program has to process data in order to produce meaningful output.
As the amount of data grows and data gets more complex, we have to think about,
how to structure that data, in order to allow efficient processing with our program.

Data Structures come in two flovours, which I will call
\begin{itemize}
  \item \emph{linked} data strucrures
  \item \emph{contiguous} data structures
\end{itemize}

in this text.

Linked data structures typically involve some kind of pointer,
where one element of the structure points to another.
Common linked structures are \emph{lists} (with subtypes like \emph{queues}
and \emph{stacks}) and \emph{trees} (with various subtypes, depending on the use case).
Linked structures are the main workhorse for functional languages like
Haskell or Scheme.

Contiguous data structures, on the other hand, are typically based on \emph{arrays}
(continuous blocks of data, closely coupled to the physical memory layout of a machine).
Common continuous structures are \emph{maps}, \emph{sets} and \emph{dictionaries},
and they are typically used in imperative languages like $C^{++}$, for good reasons.
Be aware, that some languages (e.g. Python) call their arrays lists, but even those remain
continuous structures.

Like with all things, one cannot simply tell which one is better, linked or contiguous;
it always depends on the current use case.
That said, it is obvious that both have their andvantages and disadvantages.
In this second part of the book we will explore the characteristics of some data structures,
how to implement them and when to use them and when not.

\input{List.lhs}
\input{Trees.tex}
\input{Graph.tex}
\input{Hashtable.tex}

\part{Algorithms}
\input{Algorithms.lhs}

\part{Appendix}
\appendix
\input{Solutions.lhs}

\backmatter
\chapter{Bibliography}

\end{document}
